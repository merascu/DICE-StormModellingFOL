(* Previous name of the file: Storm_mS-nB_v1_final.cub *)

(* idle = I, emit = E, execute = X, take = K 
   Assume: Execrate=1
*)

type state = I | E | X | K

(*First letter should be upper case*)
array S[proc,proc] : state
array B[proc,proc] : state
array L[proc,proc] : real
array P[proc,proc] : real
array Stime[proc, proc] : real
array BEmitTakeTime[proc, proc] : real
array Taken[proc, proc] : real
array SubscribedBS[proc, proc]: bool
array SubscribedBB[proc, proc]: bool
array Lenmax[proc]: real

var T: real
var Statechange: bool
var WasBEmitting: bool
var WasBTaking: bool
var CanTimeElapse: bool
var Execrate: real
var Tsmin: real
var Tsmax: real

(* Execrate is constant otherwise would lead to non-linearity *)
const C: real
const D: real

(* initial configuration *)
init (i x) { 
	T = 0.0 && Statechange=False && S[i,x]=I && B[i,x]=I && L[i,x]=0.0 && P[i,x]=0.0 && Stime[i,x]=0.0 && BEmitTakeTime[i,x]=0.0 &&
	WasBEmitting=False && WasBTaking=False && CanTimeElapse=True
}

(* invariant; negated invariants! *)
(* since we compare Tsmin and Lenmax they should have the same type *)
invariant()   { not (Tsmax > Tsmin) }
invariant(i j){ not (Lenmax[i] > Taken[i,j])}
invariant()   { not (Tsmax > 0.) }
invariant()   { not (Tsmin > 0.) }
invariant(i)  { not (Tsmin > Lenmax[i]) }
invariant(i)  { not (Tsmax > Lenmax[i]) }
invariant(i)  { not (Lenmax[i]  > 0.0) }

(* Taken[i,j] is a matrix which stores the number of elements taken by process j of bolt i. *)
invariant(i j){ not (Taken[i,j] > 0.0) }

(* The topology: from D3.5; 2 spouts, 3 bolts; *)
(* B1 subscribed to S1 *)
(* B2 subscribed to S1 and S2 *)
(* B3 subscribed to B1 and B2 *)

(* SubscribedBS *)
invariant(i j){ not ( i=1 && j=1  => SubscribedBS[i,j] = True ) }
invariant(i j){ not ( i=1 && j>=2 => SubscribedBS[i,j] = False ) }
invariant(i j){ not ( i=2 && j=1  => SubscribedBS[i,j] = True ) }
invariant(i j){ not ( i=2 && j=2  => SubscribedBS[i,j] = True ) }
invariant(i j){ not ( i=2 && j>2  => SubscribedBS[i,j] = False ) }
invariant(i j){ not ( i>=3        => SubscribedBS[i,j] = False ) }
(* SubscribedBB *)
invariant(i j){ not ( i=1        => SubscribedBB[i,j] = False ) }
invariant(i j){ not ( i=2        => SubscribedBB[i,j] = False ) }
invariant(i j){ not ( i=3 && j=1 => SubscribedBB[i,j] = True ) }
invariant(i j){ not ( i=3 && j=2 => SubscribedBB[i,j] = True ) }
invariant(i j){ not ( i>=3       => SubscribedBB[i,j] = False ) }
invariant() { not( Execrate = 10.0 ) }

(* unsafe states *)

(* SAFE -> what we expect: -notyping -noqe *)
unsafe(i x){L[i, x] > Lenmax[i]}

(***************)
(* TRANSITIONS *)

(* sigma_1a --> 6 transitions *)
(* S = emit and B = idle*)
transition t1a_1 (x y i j)
requires { Statechange=True}
{ 
	Statechange := False;
	S[k, t] := case 
		| t = x && k = i : E 
		| _ : S[k, t]; 
	B[l, z] := case 
		| z = y && l = j && B[j, y] =  E : I  
		| _ : B[l, z];
	CanTimeElapse := True;
}

(* S = idle and B = idle*)
transition t1a_2 (x y i j)
requires { Statechange=True}
{ 
	Statechange := False;
	S[k, t] := case 
		| t = x && k = i: I 
		| _ : S[k, t]; 
	B[l, z] := case 
		| z = y && l = j && B[j, y] =  E : I  
		| _ : B[l, z];
	CanTimeElapse := True;
}

(* S = emit and B = take*)
transition t1a_3 (x y i j)
requires { Statechange=True}
{ 
	Statechange := False;
	S[k, t] := case 
		| t = x && k = i: E 
		| _ : S[k, t]; 
	B[l, z] := case 
		| z = y && l = j && B[j, y] =  E : K  
		| _ : B[l, z];
	CanTimeElapse := True;
}

(* S = idle and B = take*)
transition t1a_4 (x y i j) 
requires { Statechange=True }
{ 
	Statechange := False;
	S[k, t] := case 
		| t = x && k = i: I 
		| _ : S[k, t]; 
	B[l, z] := case 
		| z = y && l = j && B[j, y] =  E : K  
		| _ : B[l, z];
	CanTimeElapse := True;
}

(* S = emit and B = take*)
transition t1a_5 (x y i j) 
requires { Statechange=True }
{ 
	Statechange := False;
	S[k, t] := case 
		| t = x && k = i: E 
		| _ : S[k, t]; 
	B[l, z] := case 
		| z = y && l = j && B[j, y] = I : K  
		| _ : B[l, z];
	CanTimeElapse := True;
}

(* S = idle and B = take*)
transition t1a_6 (x y i j)
requires { Statechange=True }
{ 
	Statechange := False;
	S[k, t] := case 
		| t = x && k = i: I
		| _ : S[k, t]; 
	B[l, z] := case 
		| z = y && l = j && B[j, y] = I : K  
		| _ : B[l, z];
	CanTimeElapse := True;
}

transition t1b (y j)
requires { B[j, y]=X && P[j, y]=0.0}
{ 
	Statechange := False;  
	B[l, z] := case 
		| z = y && l = j: E
		| _ : B[l, z];
	WasBEmitting := True;
	CanTimeElapse := True;
}

(* a spout emits *)
transition t2(x y i j)
requires { C >0.0 && S[i,x]=E && Tsmin<Stime[i,x]+C && Stime[i,x]+C<Tsmax && L[j,y]+D <= Lenmax[j] && SubscribedBS[j,i] = True}
{ 
   	T := T+C;
	Statechange := True;
	L[l, z] := case 
		| z = y && l = j : L[l, z] + D
		| _ : L[l, z]; 
	P[l, z] := case 
		| B[l, z] = X && 0.0 <= P[l, z]-C : P[l, z]-C
                | B[l, z] <> X                    : P[l, z]
                | B[l, z] = X && P[l, z]-C < 0.0  : 0.0;
	Stime[k, t] := case 
		| t=x && k=i : 0.0
		| _   : Stime[k, t] + C; 
	CanTimeElapse := True;
}

(* a bolt emits *)
transition t3(x y i j)
requires { (* C>0.0 && *)D>0.0 && B[i, x]=E && L[j,y]+D <= Lenmax[j] && SubscribedBB[j,i] = True}
{
    (* T := T+C;*)
    Statechange := True;
    L[l, z] := case
	| z = y && l = j : L[l, z] + D
        | _ : L[l, z];
    (* P[l, z] := case 
		| B[l, z] = X && 0.0 <= P[l, z]-C : P[l, z]-C
                | B[l, z] <> X                    : P[l, z]
                | B[l, z] =  X && P[l, z]-C < 0.0 : 0.0;
    Stime[l, z] := case |  _  : Stime[l, z] + C; *)
    CanTimeElapse := True;
}

transition t4(j y)
requires { D>0.0 && B[j, y] = K && D=Taken[j, y] && D<= L[j, y]}
{ 
	Statechange := False;
	B[l, z] := case 
		| z = y && l = j : X
		| _ : B[l, z];  
	L[l, z] := case 
		| z = y && l = j : L[l, z] - D (*Taken[j,y]*)
		| _ : L[l, z]; 
	P[l, z] := case 
		| z = y && l = j : Taken[l, z]
		| _ : P[l, z];
	(* We can not write bEmitTakeTime[j]=0 so the option is as follows *)	
        BEmitTakeTime[l, z]:= case | _: 0.0;
	WasBTaking := True;
	CanTimeElapse := True;
}
transition t5(j y)
requires { B[j, y] = K && 0.0 < L[j, y] && L[j, y]<Taken[j, y]}
{ 
	Statechange := False;  
	B[l, z] := case 
		| z = y && l = j : X
		| _ : B[l, z];  
	L[l, z] := case 
		| z = y && l = j : 0.0
		| _ : L[l, z]; 
	P[l, z] := case 
		| z = y && l = j : L[j, y]
		| _ : P[l, z];  
	BEmitTakeTime[l, z] := case | _:0.0;
	WasBTaking := True;
	CanTimeElapse := True;
}

(* time elapse *)
transition t6()
requires { 0.0<C && CanTimeElapse=True}
{ 
	T                   := T+C;
	Statechange         := True; 
	P[j, z]             := case
				|  B[j, z] = X  &&  0.0 <= P[j, z]-C: P[j, z]-C
				|  B[j, z] <> X                     : P[j, z]
				|  B[j, z] =  X && P[j, z]- C < 0.0  : 0.0;
	Stime[j, z]         := case | _: Stime[j, z] + C;
	BEmitTakeTime[j, z] := case | _: BEmitTakeTime[j, z]+C;
	CanTimeElapse       := False;
}

